<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>
    <svg id="treeSvg" width="600" height="700" viewBox="0 0 600 700">
        <!-- 나무 기둥 -->
        <rect x="270" y="380" width="60" height="320" fill="#6D4C41" rx="5"/>
        
        <!-- 나뭇잎 영역 (시각적 참고용, 투명) -->
        <ellipse id="leafArea" cx="300" cy="250" rx="180" ry="200" fill="none" stroke="none"/>
        
        <!-- 나뭇잎들이 여기에 추가됨 -->
        <g id="leavesContainer"></g>
    </svg>

    <script>
        // ===== 나뭇잎 설정 변수 =====
        const LEAF_CONFIG = {
            // 크기 설정
            minSize: 80,
            maxSize: 100,
            
            // 색상 설정 (여러 초록색 계열)
            colors: [
                '#f7570b',
                '#FF2400',
                '#D7942D',
                '#FFFF00',
                '#DFFF00',
                '#D7542D',
            ],
            
            // 안정 상태 유지 시간 (ms)
            minStableTime: 10000,
            maxStableTime: 20000,
            
            // 떨어지는 속도
            fallSpeed: 2,
            
            // 최대 나뭇잎 수
            maxLeaves: 150,
            
            // 새 잎 생성 간격 (ms)
            spawnInterval: 300,
            
            // 영역 체크 그리드 크기
            gridSize: 30
        };

        // 나뭇잎 영역 정의
        const LEAF_AREA = {
            cx: 300,
            cy: 250,
            rx: 170,
            ry: 190
        };

        // 바닥 Y 좌표
        const GROUND_Y = 650;

        // 나뭇잎 저장소
        let leaves = [];
        const leavesContainer = document.getElementById('leavesContainer');

        // 점이 타원 영역 안에 있는지 확인
        function isInsideLeafArea(x, y) {
            const dx = (x - LEAF_AREA.cx) / LEAF_AREA.rx;
            const dy = (y - LEAF_AREA.cy) / LEAF_AREA.ry;
            return (dx * dx + dy * dy) <= 1;
        }

        // 특정 위치 근처에 안정 상태인 잎이 있는지 확인
        function hasStableLeafNear(x, y, radius = LEAF_CONFIG.gridSize) {
            return leaves.some(leaf => {
                if (leaf.state !== 'stable') return false;
                const dx = leaf.x - x;
                const dy = leaf.y - y;
                return Math.sqrt(dx * dx + dy * dy) < radius;
            });
        }

        // 빈 공간 찾기
        function findEmptySpot() {
            const maxAttempts = 50;
            
            for (let i = 0; i < maxAttempts; i++) {
                // 타원 영역 내 랜덤 위치 생성
                const angle = Math.random() * Math.PI * 2;
                const r = Math.sqrt(Math.random()); // 균등 분포를 위한 sqrt
                
                const x = LEAF_AREA.cx + r * LEAF_AREA.rx * Math.cos(angle);
                const y = LEAF_AREA.cy + r * LEAF_AREA.ry * Math.sin(angle);
                
                // 해당 위치에 안정 상태 잎이 없으면 반환
                if (!hasStableLeafNear(x, y)) {
                    return { x, y };
                }
            }
            
            return null; // 빈 공간 없음
        }

        // 랜덤 값 생성 헬퍼
        function random(min, max) {
            return Math.random() * (max - min) + min;
        }

        // 나뭇잎 생성
        function createLeaf() {
            // 최대 개수 체크
            const stableLeaves = leaves.filter(l => l.state === 'stable').length;
            if (stableLeaves >= LEAF_CONFIG.maxLeaves) return;

            // 빈 공간 찾기
            const spot = findEmptySpot();
            if (!spot) return;

            const size = random(LEAF_CONFIG.minSize, LEAF_CONFIG.maxSize);
            const color = LEAF_CONFIG.colors[Math.floor(Math.random() * LEAF_CONFIG.colors.length)];
            const rotation = random(-30, 30);
            
            // SVG 사각형 요소 생성
            const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            rect.setAttribute('width', size);
            rect.setAttribute('height', size);
            rect.setAttribute('fill', color);
            rect.setAttribute('rx', '2');
            rect.setAttribute('opacity', '0.9');
            
            // 나뭇잎 객체
            const leaf = {
                element: rect,
                x: spot.x,
                y: spot.y,
                size: size,
                rotation: rotation,
                state: 'stable', // 'stable' | 'falling'
                fallRotationSpeed: random(-3, 3),
                swayOffset: random(0, Math.PI * 2),
                swaySpeed: random(0.02, 0.05),
                swayAmount: random(0.5, 2)
            };

            // 위치 업데이트
            updateLeafTransform(leaf);
            
            // 안정 시간 후 떨어지기 시작
            const stableTime = random(LEAF_CONFIG.minStableTime, LEAF_CONFIG.maxStableTime);
            setTimeout(() => {
                if (leaf.state === 'stable') {
                    leaf.state = 'falling';
                    leaf.element.setAttribute('opacity', '0.7');
                }
            }, stableTime);

            leaves.push(leaf);
            leavesContainer.appendChild(rect);
        }

        // 나뭇잎 transform 업데이트
        function updateLeafTransform(leaf) {
            const transform = `translate(${leaf.x - leaf.size/2}, ${leaf.y - leaf.size/2}) rotate(${leaf.rotation}, ${leaf.size/2}, ${leaf.size/2})`;
            leaf.element.setAttribute('transform', transform);
        }

        // 애니메이션 루프
        let lastTime = 0;
        function animate(currentTime) {
            const deltaTime = currentTime - lastTime;
            lastTime = currentTime;

            // 떨어지는 나뭇잎 업데이트
            leaves.forEach(leaf => {
                if (leaf.state === 'falling') {
                    // 아래로 이동
                    leaf.y += LEAF_CONFIG.fallSpeed;
                    
                    // 좌우 흔들림
                    leaf.x += Math.sin(currentTime * leaf.swaySpeed + leaf.swayOffset) * leaf.swayAmount;
                    
                    // 회전
                    leaf.rotation += leaf.fallRotationSpeed;
                    
                    updateLeafTransform(leaf);
                    
                    // 바닥에 닿으면 제거 예정으로 표시
                    if (leaf.y >= GROUND_Y) {
                        leaf.state = 'remove';
                    }
                }
            });

            // 제거할 잎 처리
            leaves = leaves.filter(leaf => {
                if (leaf.state === 'remove') {
                    leaf.element.remove();
                    return false;
                }
                return true;
            });

            requestAnimationFrame(animate);
        }

        // 주기적으로 새 잎 생성
        setInterval(createLeaf, LEAF_CONFIG.spawnInterval);

        // 초기 잎 생성
        for (let i = 0; i < 40; i++) {
            createLeaf();
        }

        // 애니메이션 시작
        requestAnimationFrame(animate);
    </script>
</body>
</html>
