<!DOCTYPE html>
<html lang="ko">
<head>
    <style>
        html, body {
            margin: 0;
            padding: 0;
            background: transparent;
            overflow: hidden;
        }
        svg {
            display: block;
            width: 100%;
            height: 100%;
        }
    </style>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>
    <svg id="treeSvg" width="600" height="700" viewBox="0 0 600 700">
        <!-- 나무 기둥 -->
        <rect x="270" y="380" width="60" height="320" fill="#6D4C41" rx="5"/>
        
        <!-- 나뭇잎 영역 (시각적 참고용, 투명) -->
        <polygon id="leafArea" points="300,50 120,400 480,400" fill="none" stroke="none"/>
        
        <!-- 나뭇잎들이 여기에 추가됨 -->
        <g id="leavesContainer"></g>
    </svg>

    <script>
        // ===== 나뭇잎 설정 변수 =====
        const LEAF_CONFIG = {
            // 크기 설정
            minSize: 80,
            maxSize: 100,
            
            // 색상 설정 (여러 초록색 계열)
            colors: [
                '#01796F',
                '#02796F',
                '#01896F',
                '#01797F',
                '#01696F',
                '#01716F',
            ],
            
            // 안정 상태 유지 시간 (ms)
            minStableTime: 10000,
            maxStableTime: 20000,
            
            // 떨어지는 속도
            fallSpeed: 2,
            
            // 최대 나뭇잎 수
            maxLeaves: 150,
            
            // 새 잎 생성 간격 (ms)
            spawnInterval: 300,
            
            // 영역 체크 그리드 크기
            gridSize: 30
        };

        // 삼각형 나뭇잎 영역 정의 (꼭지점 3개)
        const TRIANGLE = {
            p1: { x: 300, y: 50 },   // 꼭대기
            p2: { x: 120, y: 500 },  // 왼쪽 아래
            p3: { x: 480, y: 500 }   // 오른쪽 아래
        };

        // 바닥 Y 좌표
        const GROUND_Y = 650;

        // 나뭇잎 저장소
        let leaves = [];
        const leavesContainer = document.getElementById('leavesContainer');

        // 삼각형의 부호 있는 면적 계산 (점이 삼각형 안에 있는지 확인용)
        function sign(p1, p2, p3) {
            return (p1.x - p3.x) * (p2.y - p3.y) - (p2.x - p3.x) * (p1.y - p3.y);
        }

        // 점이 삼각형 영역 안에 있는지 확인
        function isInsideLeafArea(x, y) {
            const pt = { x, y };
            const d1 = sign(pt, TRIANGLE.p1, TRIANGLE.p2);
            const d2 = sign(pt, TRIANGLE.p2, TRIANGLE.p3);
            const d3 = sign(pt, TRIANGLE.p3, TRIANGLE.p1);

            const hasNeg = (d1 < 0) || (d2 < 0) || (d3 < 0);
            const hasPos = (d1 > 0) || (d2 > 0) || (d3 > 0);

            return !(hasNeg && hasPos);
        }

        // 특정 위치 근처에 안정 상태인 잎이 있는지 확인
        function hasStableLeafNear(x, y, radius = LEAF_CONFIG.gridSize) {
            return leaves.some(leaf => {
                if (leaf.state !== 'stable') return false;
                const dx = leaf.x - x;
                const dy = leaf.y - y;
                return Math.sqrt(dx * dx + dy * dy) < radius;
            });
        }

        // 삼각형 내부의 랜덤 점 생성 (바리센트릭 좌표 사용)
        function randomPointInTriangle() {
            let r1 = Math.random();
            let r2 = Math.random();
            
            // 균등 분포를 위한 변환
            if (r1 + r2 > 1) {
                r1 = 1 - r1;
                r2 = 1 - r2;
            }
            
            const x = TRIANGLE.p1.x + r1 * (TRIANGLE.p2.x - TRIANGLE.p1.x) + r2 * (TRIANGLE.p3.x - TRIANGLE.p1.x);
            const y = TRIANGLE.p1.y + r1 * (TRIANGLE.p2.y - TRIANGLE.p1.y) + r2 * (TRIANGLE.p3.y - TRIANGLE.p1.y);
            
            return { x, y };
        }

        // 빈 공간 찾기
        function findEmptySpot() {
            const maxAttempts = 50;
            
            for (let i = 0; i < maxAttempts; i++) {
                // 삼각형 영역 내 랜덤 위치 생성
                const point = randomPointInTriangle();
                
                // 해당 위치에 안정 상태 잎이 없으면 반환
                if (!hasStableLeafNear(point.x, point.y)) {
                    return point;
                }
            }
            
            return null; // 빈 공간 없음
        }

        // 랜덤 값 생성 헬퍼
        function random(min, max) {
            return Math.random() * (max - min) + min;
        }

        // 나뭇잎 생성
        function createLeaf() {
            // 최대 개수 체크
            const stableLeaves = leaves.filter(l => l.state === 'stable').length;
            if (stableLeaves >= LEAF_CONFIG.maxLeaves) return;

            // 빈 공간 찾기
            const spot = findEmptySpot();
            if (!spot) return;

            const size = random(LEAF_CONFIG.minSize, LEAF_CONFIG.maxSize);
            const color = LEAF_CONFIG.colors[Math.floor(Math.random() * LEAF_CONFIG.colors.length)];
            const rotation = random(-30, 30);
            
            // SVG 사각형 요소 생성
            const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            rect.setAttribute('width', size);
            rect.setAttribute('height', size);
            rect.setAttribute('fill', color);
            rect.setAttribute('rx', '2');
            rect.setAttribute('opacity', '0.9');
            
            // 나뭇잎 객체
            const leaf = {
                element: rect,
                x: spot.x,
                y: spot.y,
                size: size,
                rotation: rotation,
                state: 'stable', // 'stable' | 'falling'
                fallRotationSpeed: random(-3, 3),
                swayOffset: random(0, Math.PI * 2),
                swaySpeed: random(0.02, 0.05),
                swayAmount: random(0.5, 2)
            };

            // 위치 업데이트
            updateLeafTransform(leaf);
            
            // 안정 시간 후 떨어지기 시작
            const stableTime = random(LEAF_CONFIG.minStableTime, LEAF_CONFIG.maxStableTime);
            setTimeout(() => {
                if (leaf.state === 'stable') {
                    leaf.state = 'falling';
                    leaf.element.setAttribute('opacity', '0.7');
                }
            }, stableTime);

            leaves.push(leaf);
            leavesContainer.appendChild(rect);
        }

        // 나뭇잎 transform 업데이트
        function updateLeafTransform(leaf) {
            const transform = `translate(${leaf.x - leaf.size/2}, ${leaf.y - leaf.size/2}) rotate(${leaf.rotation}, ${leaf.size/2}, ${leaf.size/2})`;
            leaf.element.setAttribute('transform', transform);
        }

        // 애니메이션 루프
        let lastTime = 0;
        function animate(currentTime) {
            const deltaTime = currentTime - lastTime;
            lastTime = currentTime;

            // 떨어지는 나뭇잎 업데이트
            leaves.forEach(leaf => {
                if (leaf.state === 'falling') {
                    // 아래로 이동
                    leaf.y += LEAF_CONFIG.fallSpeed;
                    
                    // 좌우 흔들림
                    leaf.x += Math.sin(currentTime * leaf.swaySpeed + leaf.swayOffset) * leaf.swayAmount;
                    
                    // 회전
                    leaf.rotation += leaf.fallRotationSpeed;
                    
                    updateLeafTransform(leaf);
                    
                    // 바닥에 닿으면 제거 예정으로 표시
                    if (leaf.y >= GROUND_Y) {
                        leaf.state = 'remove';
                    }
                }
            });

            // 제거할 잎 처리
            leaves = leaves.filter(leaf => {
                if (leaf.state === 'remove') {
                    leaf.element.remove();
                    return false;
                }
                return true;
            });

            requestAnimationFrame(animate);
        }

        // 주기적으로 새 잎 생성
        setInterval(createLeaf, LEAF_CONFIG.spawnInterval);

        // 초기 잎 생성
        for (let i = 0; i < 40; i++) {
            createLeaf();
        }

        // 애니메이션 시작
        requestAnimationFrame(animate);
    </script>
</body>
</html>