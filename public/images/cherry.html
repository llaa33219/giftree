<!DOCTYPE html>
<html lang="ko">
<head>
    <style>
        html, body {
            margin: 0;
            padding: 0;
            background: transparent;
            overflow: hidden;
        }
        svg {
            display: block;
            width: 100%;
            height: 100%;
        }
    </style>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>
    <svg id="treeSvg" width="600" height="700" viewBox="0 0 600 700">
        <!-- 나무 기둥 -->
        <rect x="270" y="380" width="60" height="320" fill="#6D4C41" rx="5"/>
        
        <!-- 나뭇잎 영역 (시각적 참고용, 투명) -->
        <ellipse id="leafArea" cx="300" cy="250" rx="180" ry="200" fill="none" stroke="none"/>
        
        <!-- 나뭇잎들이 여기에 추가됨 -->
        <g id="leavesContainer"></g>
    </svg>

    <script>
        // ===== 나뭇잎 설정 변수 =====
        const LEAF_CONFIG = {
            // 크기 설정
            minSize: 80,
            maxSize: 100,
            
            // 색상 설정
            colors: [
                '#ff6b87',
                '#ff849c',
                '#ff9eb0',
                '#ffb7c5',
                '#ffeaee',
                '#ffffff',
            ],
            
            // 떨어지는 속도
            fallSpeed: 2,
            
            // 목표 안정 잎 개수 (이 개수를 유지하려고 함)
            targetLeaves: 30,
            
            // 최대 나뭇잎 수
            maxLeaves: 150,
            
            // 새 잎 생성 간격 (ms)
            spawnInterval: 700,
            
            // 개수 체크 간격 (ms)
            checkInterval: 500,
            
            // 초과 시 떨어뜨릴 비율 (0.0 ~ 1.0)
            fallRatio: 0.2,
            
            // 영역 체크 그리드 크기
            gridSize: 30
        };

        // 나뭇잎 영역 정의
        const LEAF_AREA = {
            cx: 300,
            cy: 250,
            rx: 170,
            ry: 190
        };

        // 바닥 Y 좌표
        const GROUND_Y = 650;

        // 나뭇잎 저장소
        let leaves = [];
        const leavesContainer = document.getElementById('leavesContainer');

        // 점이 타원 영역 안에 있는지 확인
        function isInsideLeafArea(x, y) {
            const dx = (x - LEAF_AREA.cx) / LEAF_AREA.rx;
            const dy = (y - LEAF_AREA.cy) / LEAF_AREA.ry;
            return (dx * dx + dy * dy) <= 1;
        }

        // 특정 위치 근처에 안정 상태인 잎이 있는지 확인
        function hasStableLeafNear(x, y, radius = LEAF_CONFIG.gridSize) {
            return leaves.some(leaf => {
                if (leaf.state !== 'stable') return false;
                const dx = leaf.x - x;
                const dy = leaf.y - y;
                return Math.sqrt(dx * dx + dy * dy) < radius;
            });
        }

        // 특정 위치에서 가장 가까운 안정 잎까지의 거리
        function distanceToNearestStableLeaf(x, y) {
            let minDist = Infinity;
            leaves.forEach(leaf => {
                if (leaf.state !== 'stable') return;
                const dx = leaf.x - x;
                const dy = leaf.y - y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist < minDist) minDist = dist;
            });
            return minDist;
        }

        // 그리드 기반 빈 공간 찾기 (가장 크게 비어있는 곳 우선)
        function findEmptySpot() {
            const gridSize = LEAF_CONFIG.gridSize;
            let bestCell = null;
            let maxDistance = 0;
            
            // 타원 영역을 그리드로 스캔
            for (let x = LEAF_AREA.cx - LEAF_AREA.rx; x <= LEAF_AREA.cx + LEAF_AREA.rx; x += gridSize) {
                for (let y = LEAF_AREA.cy - LEAF_AREA.ry; y <= LEAF_AREA.cy + LEAF_AREA.ry; y += gridSize) {
                    // 타원 내부인지 확인
                    if (!isInsideLeafArea(x, y)) continue;
                    
                    const dist = distanceToNearestStableLeaf(x, y);
                    
                    // 가장 멀리 떨어진 (가장 비어있는) 위치 선택
                    if (dist > maxDistance) {
                        maxDistance = dist;
                        bestCell = { x, y };
                    }
                }
            }
            
            if (!bestCell) return null;
            
            // 약간의 랜덤 오프셋 추가
            const offsetX = (Math.random() - 0.5) * gridSize * 0.5;
            const offsetY = (Math.random() - 0.5) * gridSize * 0.5;
            
            return { 
                x: bestCell.x + offsetX, 
                y: bestCell.y + offsetY 
            };
        }

        // 랜덤 값 생성 헬퍼
        function random(min, max) {
            return Math.random() * (max - min) + min;
        }

        // 나뭇잎 생성
        function createLeaf() {
            const stableLeaves = leaves.filter(l => l.state === 'stable').length;
            if (stableLeaves >= LEAF_CONFIG.maxLeaves) return;

            const spot = findEmptySpot();
            if (!spot) return;

            const size = random(LEAF_CONFIG.minSize, LEAF_CONFIG.maxSize);
            const color = LEAF_CONFIG.colors[Math.floor(Math.random() * LEAF_CONFIG.colors.length)];
            const rotation = random(-30, 30);
            
            const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            rect.setAttribute('width', size);
            rect.setAttribute('height', size);
            rect.setAttribute('fill', color);
            rect.setAttribute('rx', '2');
            rect.setAttribute('opacity', '0.9');
            
            const leaf = {
                element: rect,
                x: spot.x,
                y: spot.y,
                size: size,
                rotation: rotation,
                state: 'stable',
                fallRotationSpeed: random(-3, 3),
                swayOffset: random(0, Math.PI * 2),
                swaySpeed: random(0.02, 0.05),
                swayAmount: random(0.5, 2)
            };

            updateLeafTransform(leaf);

            leaves.push(leaf);
            leavesContainer.appendChild(rect);
        }

        // 개수 체크 및 초과분 떨어뜨리기
        function checkAndDropExcess() {
            const stableLeaves = leaves.filter(l => l.state === 'stable');
            const excess = stableLeaves.length - LEAF_CONFIG.targetLeaves;
            
            if (excess > 0) {
                // 초과분의 일부를 랜덤하게 떨어뜨림
                const dropCount = Math.max(1, Math.ceil(excess * LEAF_CONFIG.fallRatio));
                
                // 랜덤하게 섞어서 선택
                const shuffled = stableLeaves.sort(() => Math.random() - 0.5);
                const toDrop = shuffled.slice(0, dropCount);
                
                toDrop.forEach(leaf => {
                    leaf.state = 'falling';
                    leaf.element.setAttribute('opacity', '0.7');
                });
            }
        }

        // 나뭇잎 transform 업데이트
        function updateLeafTransform(leaf) {
            const transform = `translate(${leaf.x - leaf.size/2}, ${leaf.y - leaf.size/2}) rotate(${leaf.rotation}, ${leaf.size/2}, ${leaf.size/2})`;
            leaf.element.setAttribute('transform', transform);
        }

        // 애니메이션 루프
        let lastTime = 0;
        function animate(currentTime) {
            const deltaTime = currentTime - lastTime;
            lastTime = currentTime;

            leaves.forEach(leaf => {
                if (leaf.state === 'falling') {
                    leaf.y += LEAF_CONFIG.fallSpeed;
                    leaf.x += Math.sin(currentTime * leaf.swaySpeed + leaf.swayOffset) * leaf.swayAmount;
                    leaf.rotation += leaf.fallRotationSpeed;
                    
                    updateLeafTransform(leaf);
                    
                    if (leaf.y >= GROUND_Y) {
                        leaf.state = 'remove';
                    }
                }
            });

            leaves = leaves.filter(leaf => {
                if (leaf.state === 'remove') {
                    leaf.element.remove();
                    return false;
                }
                return true;
            });

            requestAnimationFrame(animate);
        }

        // 주기적으로 새 잎 생성
        setInterval(createLeaf, LEAF_CONFIG.spawnInterval);

        // 주기적으로 개수 체크 및 초과분 떨어뜨리기
        setInterval(checkAndDropExcess, LEAF_CONFIG.checkInterval);

        // 초기 잎 생성
        for (let i = 0; i < 40; i++) {
            createLeaf();
        }

        // 애니메이션 시작
        requestAnimationFrame(animate);
    </script>
</body>
</html>