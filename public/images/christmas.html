<!DOCTYPE html>
<html lang="ko">
<head>
    <style>
        html, body {
            margin: 0;
            padding: 0;
            background: transparent;
            overflow: hidden;
        }
        svg {
            display: block;
            width: 100%;
            height: 100%;
        }
    </style>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>
    <svg id="treeSvg" width="600" height="700" viewBox="0 0 600 700">
        <!-- 나무 기둥 -->
        <rect x="270" y="380" width="60" height="320" fill="#6D4C41" rx="5"/>
        
        <!-- 나뭇잎 영역 (시각적 참고용, 투명) -->
        <polygon id="leafArea" points="300,50 120,400 480,400" fill="none" stroke="none"/>
        
        <!-- 나뭇잎들이 여기에 추가됨 -->
        <g id="leavesContainer"></g>
    </svg>

    <script>
        // ===== 나뭇잎 설정 변수 =====
        const LEAF_CONFIG = {
            // 크기 설정
            minSize: 80,
            maxSize: 100,
            
            // 색상 설정
            colors: [
                '#075600',
                '#355829',
                '#135834',
                '#F0F0F0',
                '#EEEEEE',
                '#FFFFFF',
                '#EE0000',
                '#EEEE00',
            ],
            
            // 떨어지는 속도
            fallSpeed: 2,
            
            // 목표 안정 잎 개수 (이 개수를 유지하려고 함)
            targetLeaves: 30,
            
            // 최대 나뭇잎 수
            maxLeaves: 150,
            
            // 새 잎 생성 간격 (ms)
            spawnInterval: 700,
            
            // 개수 체크 간격 (ms)
            checkInterval: 500,
            
            // 초과 시 떨어뜨릴 비율 (0.0 ~ 1.0)
            fallRatio: 0.2,
            
            // 영역 체크 그리드 크기
            gridSize: 30
        };

        // 삼각형 나뭇잎 영역 정의
        const TRIANGLE = {
            p1: { x: 300, y: 50 },
            p2: { x: 120, y: 500 },
            p3: { x: 480, y: 500 }
        };

        // 바닥 Y 좌표
        const GROUND_Y = 650;

        // 나뭇잎 저장소
        let leaves = [];
        const leavesContainer = document.getElementById('leavesContainer');

        // 삼각형의 부호 있는 면적 계산
        function sign(p1, p2, p3) {
            return (p1.x - p3.x) * (p2.y - p3.y) - (p2.x - p3.x) * (p1.y - p3.y);
        }

        // 점이 삼각형 영역 안에 있는지 확인
        function isInsideLeafArea(x, y) {
            const pt = { x, y };
            const d1 = sign(pt, TRIANGLE.p1, TRIANGLE.p2);
            const d2 = sign(pt, TRIANGLE.p2, TRIANGLE.p3);
            const d3 = sign(pt, TRIANGLE.p3, TRIANGLE.p1);

            const hasNeg = (d1 < 0) || (d2 < 0) || (d3 < 0);
            const hasPos = (d1 > 0) || (d2 > 0) || (d3 > 0);

            return !(hasNeg && hasPos);
        }

        // 특정 위치 근처에 안정 상태인 잎이 있는지 확인
        function hasStableLeafNear(x, y, radius = LEAF_CONFIG.gridSize) {
            return leaves.some(leaf => {
                if (leaf.state !== 'stable') return false;
                const dx = leaf.x - x;
                const dy = leaf.y - y;
                return Math.sqrt(dx * dx + dy * dy) < radius;
            });
        }

        // 삼각형 내부의 랜덤 점 생성
        function randomPointInTriangle() {
            let r1 = Math.random();
            let r2 = Math.random();
            
            if (r1 + r2 > 1) {
                r1 = 1 - r1;
                r2 = 1 - r2;
            }
            
            const x = TRIANGLE.p1.x + r1 * (TRIANGLE.p2.x - TRIANGLE.p1.x) + r2 * (TRIANGLE.p3.x - TRIANGLE.p1.x);
            const y = TRIANGLE.p1.y + r1 * (TRIANGLE.p2.y - TRIANGLE.p1.y) + r2 * (TRIANGLE.p3.y - TRIANGLE.p1.y);
            
            return { x, y };
        }

        // 특정 위치에서 가장 가까운 안정 잎까지의 거리
        function distanceToNearestStableLeaf(x, y) {
            let minDist = Infinity;
            leaves.forEach(leaf => {
                if (leaf.state !== 'stable') return;
                const dx = leaf.x - x;
                const dy = leaf.y - y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist < minDist) minDist = dist;
            });
            return minDist;
        }

        // 그리드 기반 빈 공간 찾기 (가장 크게 비어있는 곳 우선)
        function findEmptySpot() {
            const gridSize = LEAF_CONFIG.gridSize;
            let bestCell = null;
            let maxDistance = 0;
            
            // 삼각형 바운딩 박스 내 그리드 스캔
            const minX = Math.min(TRIANGLE.p1.x, TRIANGLE.p2.x, TRIANGLE.p3.x);
            const maxX = Math.max(TRIANGLE.p1.x, TRIANGLE.p2.x, TRIANGLE.p3.x);
            const minY = Math.min(TRIANGLE.p1.y, TRIANGLE.p2.y, TRIANGLE.p3.y);
            const maxY = Math.max(TRIANGLE.p1.y, TRIANGLE.p2.y, TRIANGLE.p3.y);
            
            for (let x = minX; x <= maxX; x += gridSize) {
                for (let y = minY; y <= maxY; y += gridSize) {
                    // 삼각형 내부인지 확인
                    if (!isInsideLeafArea(x, y)) continue;
                    
                    const dist = distanceToNearestStableLeaf(x, y);
                    
                    // 가장 멀리 떨어진 (가장 비어있는) 위치 선택
                    if (dist > maxDistance) {
                        maxDistance = dist;
                        bestCell = { x, y };
                    }
                }
            }
            
            if (!bestCell) return null;
            
            // 약간의 랜덤 오프셋 추가
            const offsetX = (Math.random() - 0.5) * gridSize * 0.5;
            const offsetY = (Math.random() - 0.5) * gridSize * 0.5;
            
            return { 
                x: bestCell.x + offsetX, 
                y: bestCell.y + offsetY 
            };
        }

        // 랜덤 값 생성 헬퍼
        function random(min, max) {
            return Math.random() * (max - min) + min;
        }

        // 나뭇잎 생성
        function createLeaf() {
            const stableLeaves = leaves.filter(l => l.state === 'stable').length;
            if (stableLeaves >= LEAF_CONFIG.maxLeaves) return;

            const spot = findEmptySpot();
            if (!spot) return;

            const size = random(LEAF_CONFIG.minSize, LEAF_CONFIG.maxSize);
            const color = LEAF_CONFIG.colors[Math.floor(Math.random() * LEAF_CONFIG.colors.length)];
            const rotation = random(-30, 30);
            
            const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            rect.setAttribute('width', size);
            rect.setAttribute('height', size);
            rect.setAttribute('fill', color);
            rect.setAttribute('rx', '2');
            rect.setAttribute('opacity', '0.9');
            
            const leaf = {
                element: rect,
                x: spot.x,
                y: spot.y,
                size: size,
                rotation: rotation,
                state: 'stable',
                fallRotationSpeed: random(-3, 3),
                swayOffset: random(0, Math.PI * 2),
                swaySpeed: random(0.02, 0.05),
                swayAmount: random(0.5, 2)
            };

            updateLeafTransform(leaf);

            leaves.push(leaf);
            leavesContainer.appendChild(rect);
        }

        // 개수 체크 및 초과분 떨어뜨리기
        function checkAndDropExcess() {
            const stableLeaves = leaves.filter(l => l.state === 'stable');
            const excess = stableLeaves.length - LEAF_CONFIG.targetLeaves;
            
            if (excess > 0) {
                const dropCount = Math.max(1, Math.ceil(excess * LEAF_CONFIG.fallRatio));
                const shuffled = stableLeaves.sort(() => Math.random() - 0.5);
                const toDrop = shuffled.slice(0, dropCount);
                
                toDrop.forEach(leaf => {
                    leaf.state = 'falling';
                    leaf.element.setAttribute('opacity', '0.7');
                });
            }
        }

        // 나뭇잎 transform 업데이트
        function updateLeafTransform(leaf) {
            const transform = `translate(${leaf.x - leaf.size/2}, ${leaf.y - leaf.size/2}) rotate(${leaf.rotation}, ${leaf.size/2}, ${leaf.size/2})`;
            leaf.element.setAttribute('transform', transform);
        }

        // 애니메이션 루프
        let lastTime = 0;
        function animate(currentTime) {
            const deltaTime = currentTime - lastTime;
            lastTime = currentTime;

            leaves.forEach(leaf => {
                if (leaf.state === 'falling') {
                    leaf.y += LEAF_CONFIG.fallSpeed;
                    leaf.x += Math.sin(currentTime * leaf.swaySpeed + leaf.swayOffset) * leaf.swayAmount;
                    leaf.rotation += leaf.fallRotationSpeed;
                    
                    updateLeafTransform(leaf);
                    
                    if (leaf.y >= GROUND_Y) {
                        leaf.state = 'remove';
                    }
                }
            });

            leaves = leaves.filter(leaf => {
                if (leaf.state === 'remove') {
                    leaf.element.remove();
                    return false;
                }
                return true;
            });

            requestAnimationFrame(animate);
        }

        // 주기적으로 새 잎 생성
        setInterval(createLeaf, LEAF_CONFIG.spawnInterval);

        // 주기적으로 개수 체크 및 초과분 떨어뜨리기
        setInterval(checkAndDropExcess, LEAF_CONFIG.checkInterval);

        // 초기 잎 생성
        for (let i = 0; i < 40; i++) {
            createLeaf();
        }

        // 애니메이션 시작
        requestAnimationFrame(animate);
    </script>
</body>
</html>